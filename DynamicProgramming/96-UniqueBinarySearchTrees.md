# 96. Unique Binary Search Trees

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](assets/uniquebstn3-20240228205139544.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

**提示：**

-   `1 <= n <= 19`



```java
class Solution {
  // BST 关键的性质是根节点的值大于左子树所有节点的值, 小于右子树所有节点的值, 且左子树和右子树也同样为 BST
  // 因此在生成所有可行的 BST 的时候, 假设当前序列长度为 n, 如果我们枚举根节点的值为 i, 那么根据 BST 的性质我们可以知道左子树的节点值的集合为 [1 … i−1], 右子树的节点值的集合为 [i+1 … n]
  public int numTrees(int n) {
    // dp[i] 代表长度为 i 的序列 (n = i) 能构成的不同 BST 的个数
    int[] dp = new int[n + 1];
    // n = 0 是空树, 也算做一种情况
    dp[0] = 1;
    dp[1] = 1;

    // dp[i] 等于遍历所有以 j 为根 (1 <= j <= i) 的以 i 为长度的不同 BST 的个数 (dp(j, i)) 的总和
    // dp[i] = sum from j = 1 to j = i of dp(j, i)
    // 若创建以 3 为根, n = 7 的不同 BST, 整个序列是 [1, 2, 3, 4, 5, 6, 7], 我们需要从子左序列 [1, 2] 构建的不同左子树的数量, 从子右序列 [4, 5, 6, 7] 构建的不同右子树的数量, 然后将他们相乘
    // 对于这个例子, 不同 BST 的个数为 dp(j=3, i=7), 我们将 [1, 2] 构建不同左子树的数量表示为 dp[2], [4, 5, 6, 7] 构建不同右子树的数量表示为 dp[4] (注: dp[n] 和序列的内容无关, 只和序列的长度有关), 于是 dp(j=3, i=7) = dp(j=2, i=7) * dp(j=4, i=7)
    // 所以, 若我们想求得 dp[7], 我们需要把 j 从 1 遍历到 7 的所有 dp(j, 7) 加起来, 就是结果
    for (int i = 2; i <= n; i++) {
      for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
      }
    }

    return dp[n];
  }
}
```

