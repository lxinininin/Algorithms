# 172. Factorial Trailing Zeros

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

 

**示例 1：**

```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

**示例 2：**

```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

**示例 3：**

```
输入：n = 0
输出：0
```

 

**提示：**

-   `0 <= n <= 104`

 

**进阶：**你可以设计并实现对数时间复杂度的算法来解决此问题吗？



**方法一: 数学**

n! 尾零的数量即为 n! 中因子 10 的个数, 而 10 = 2 * 5, 因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值.

由于质因子 5 的个数不会大于质因子 2 的个数, 我们可以仅仅考虑质因子 5 的个数

```java
class Solution {
  public int trailingZeroes(int n) {
    int ans = 0;
    // 这儿我们寻找 5, 10, 15, 20, 25, 30 ...
    for (int i = 5; i <= n; i += 5) {
      int x = i;
      // 这个我们寻找每个数质因子 5 的个数
      // ex: 5 的质因子个数为 1, 10 的也为 1, 15 的也为 1...
      // 25 的质因子个数为 2 (5 * 5 = 25)
      while (x % 5 == 0) {
        ans++;
        x /= 5;
      }
    }

    return ans;
  }
}
```



**方法二: 优化计算**

换一个角度考虑 [1, n] 中质因子 5 的个数

[1, n] 中 5 的倍数有 n / 5 个, 这些数至少贡献出了 n / 5 个质因子.

25 的倍数有 n / 25 个, 由于这些数已经是 5 的倍数了, 为了不重复统计 5 的个数, 我们仅考虑额外贡献的质因子个数, 即这些数额外贡献了至少 n / 25 个质因子 5, 然后依此类推

```java
class Solution {
  public int trailingZeroes(int n) {
    int ans = 0;
    while (n != 0) {
      n /= 5;
      ans += n;
    }
    return ans;
  }
}
```

